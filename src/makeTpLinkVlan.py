#-----------------------------------------------------
#--  Génération de configuration de switch tp-link
#--  ma logique est de définir les vlans sur les ports,
#--  tp-link, fait le contraire
#--  
#--   structure du fichier json
#--  {
#--      "vlans": tableau des vlans
#--      [
#--         {
#--             "num": numéro du port,
#--             "name": num du vlan
#--         }
#--      ],
#--      "trunk":[ liste des vlans],
#--      "ports": tableau des ports
#--      [
#--          {
#--             "num": [liste des ports ayant le même comportement], 
#--             "tagged": tableau des vlans sur ce port,
#--             [
#--                 numero du vlan
#--             ],
#--             "trunk": true pour utliser les vlans definis dans trunk, prioritaire sur tagged
#--             "untagged": id du vlan, 1 si absent
#--             "hybrid": idem untagged, mais force l'utilisation en pvid
#--          },
#--      ]
#--  }
#--  
#--  
#-----------------------------------------------------


from io import TextIOWrapper
import ipaddress
import json
from datetime import datetime
import commun


f:TextIOWrapper=None


def main():
    descriptorFn = commun.getArgv("-process", '/home/oec/DEV/Mikrotik/out/tplink.json')
    if ( len(descriptorFn) == 0 ):
        print("-process is mandatory")
        return
    fn = commun.getArgv("-toFile", '/home/oec/DEV/Mikrotik/out/tplink.txt')
    if ( len(fn) == 0 ):
        print("-toFile is mandatory")
        return

    descriptor = commun.dataLoad(descriptorFn)
    if ( len(descriptor) == 0 ):
        print("file %s is empty" % (descriptorFn) )
        return

    j = json.loads(descriptor)

    # vlan names
    vlanName={}
    # liste des ports par vlan tagged
    vlansTaggedPorts={} 
    # liste des ports par vlan untagged
    vlansUntaggetPorts={} 
    # pvid liste des ports par vlan
    vlansPvid={}
    # liste des ports (numero)
    ports=[]
    # vlans du trunk
    trunk=[]
    # last port number
    lastPort = 0

    for vlansTag in j["vlans"]:
        vlanId = vlansTag["num"]
        if vlanId in vlanName:
            print("vlan %d already defined in vlans, skipping" % (vlanId) )
        else:
            vlanName[vlanId] = vlansTag["name"]

    trunk = j.get("trunk", [])

    for portTag in j["ports"]:        
        # # port = portTag["num"]
        # vlan tagged, trunk prioritaire
        if (isPresent(portTag, "trunk") and isPresent(portTag, "tagged") ):
            print("port %d both trunk and tagged present, taking tagged " % (port) )
        vlanTagged = portTag.get("tagged", [])
        if (len(vlanTagged) == 0):
            if portTag.get("trunk", False) == True:
                vlanTagged = trunk
    
        # vlan untagged
        vlanUntagged = 0
        vlanHybrid = vlanUntagged
        if isPresent(portTag, "untagged")==True:
            vlanUntagged = portTag["untagged"]
            vlanHybrid = vlanUntagged
        elif isPresent(portTag, "hybrid")==True:
            vlanHybrid = portTag["hybrid"]
        if vlanUntagged in vlanTagged:
            vlanTagged.remove(vlanUntagged)

        # reason = valid(portTag)
        
        for port in portTag["num"]:
            if port in ports:
                print("port %d already defined in ports, skipping" % (port) )
            else:
                if (port > lastPort):
                    lastPort = port

                # generation du modèle TP-Link
                ports.append(port)

                # liste des ports pour le vlan untagged
                temp = []
                if (vlanHybrid > 0):
                    value = vlansPvid.get(vlanHybrid, [])
                    value.append(port)
                    vlansPvid[vlanHybrid] = value
                
                if (vlanUntagged > 0):
                    temp.append(vlanUntagged)
                
                # liste des ports pour un vlan tagged
                updateList(port, vlansTaggedPorts, vlanTagged, vlanName)

                # liste des ports pour un vlan untagged
                updateList(port, vlansUntaggetPorts, temp, vlanName)


    # some global checks
    for p in range(1, lastPort):
        if ( p not in ports):
            print("port %d is missing definition" % (p) );

    global f
    f = open(fn, 'w')

    write(  '#######################################################################################')
    write(  '# configuration generated by ohmi')
    write(  '#     script:makeTpLinkVlan.py')
    write( ('#     Source: %s' % (descriptorFn) ) )
    write( ('#     on: %s' % (datetime.now().strftime("%Y/%m/%d %H:%M:%S") ) ) )
    write(  '#######################################################################################')
    write( "" )

    write(  '###############')
    write(  "# 802.1Q VLAN")
    write(  '###############')
    write( "" )
    for vlanId, name in vlanName.items():
        write("  vlan : %d name: %s" % (vlanId, name) )
        tmp=""
        if (vlanId in vlansTaggedPorts):
            for port in vlansTaggedPorts[vlanId]:
                tmp = tmp + ' ' + str(port) + ','
            write("    tagged : %s" % (tmp))
        tmp=""
        if (vlanId in vlansUntaggetPorts):
            for port in vlansUntaggetPorts[vlanId]:
                tmp = tmp + ' ' + str(port) + ','
            if len(tmp) > 0:
                write("    untagged : %s" % (tmp))
        write( "" )
    
    write( "" )
    write(  '#######################')
    write(  "# 802.1Q PVID setting")
    write(  '#######################')
    write( "" )
    for vlanId, portList in vlansPvid.items():
        write("  pvid : %d" % (vlanId) )
        tmp=""
        for port in portList:
            tmp = tmp + ' ' + str(port) + ','
        write("    ports : %s" % (tmp))
        write( "" )

    f.close()


def write(s:str)->None:
    f.write('%s\n' % (s) )


def updateList(port, mainList, portList, validVlans):
    for tag in portList:
        if tag in validVlans:
            value = mainList.get(tag, [])
            value.append(port)
            mainList[tag] = value
        else:
            print("vlan %d not defined in vlans for port %d, skipping" % (tag, port) )


# def valid(port)->str:
#     # isHybrid   = isPresent(port, "hybrid")
#     isTrunk    = isPresent(port, "trunk")
#     isTagged   = isPresent(port, "tagged")
#     isUntagged = isPresent(port, "untagged")
#     invalid=""
#     if (isTrunk and isTagged):
#         invalid="trunk/tagged"
#     # elif (isHybrid and isUntagged):
#     #     invalid = "hybrid/untagged"
#     return invalid

def isPresent(json, tag):
    rc = tag in json
    return rc

main()
