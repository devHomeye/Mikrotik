#-----------------------------------------------------
#--  Génération de configuration de switch tp-link
#--  ma logique est de définir les vlans sur les ports,
#--  tp-link, fait le contraire
#--  
#--   structure du fichier json
#--  {
#--      "vlans": tableau des vlans
#--      [
#--         {
#--             "num": numéro du port,
#--             "name": num du vlan
#--         }
#--      ],
#--      "trunk":[ liste des vlans],
#--      "ports": tableau des ports
#--      [
#--          {
#--             "num": numero du port, 
#--             "tagged": tableau des vlans sur ce port,
#--             [
#--                 numero du vlan
#--             ],
#--             "untagged": id du vlan, 1 si absent
#--             "hybrid": id du vlan, idem untagged, mais supprimer ce vlan des tagged si present
#--             "trunk": true pour utliser les vlans definis dans trunk
#--          },
#--      ]
#--  }
#--  
#--  
#-----------------------------------------------------


from io import TextIOWrapper
import ipaddress
import json
from datetime import datetime
import commun


f:TextIOWrapper=None


def main():
    descriptorFn = commun.getArgv("-process", '/home/oec/DEV/Mikrotik/out/tplink.json')
    if ( len(descriptorFn) == 0 ):
        print("-process is mandatory")
        return
    fn = commun.getArgv("-toFile", '/home/oec/DEV/Mikrotik/out/tplink.txt')
    if ( len(fn) == 0 ):
        print("-toFile is mandatory")
        return

    descriptor = commun.dataLoad(descriptorFn)
    if ( len(descriptor) == 0 ):
        print("file %s is empty" % (descriptorFn) )
        return

    j = json.loads(descriptor)

    # vlan names
    vlanName={}
    # liste des ports par vlan tagged
    vlansTaggedPorts={} 
    # liste des ports par vlan untagged
    vlansUntaggetPorts={} 
    # pvid liste des ports par vlan
    vlansPvid={}
    # liste des ports (numero)
    ports=[]
    # vlans du trunk
    trunk=[]

    for vlansTag in j["vlans"]:
        vlanId = vlansTag["num"]
        if vlanId in vlanName:
            print("vlan %d already defined in vlans, skipping" % (vlanId) )
        else:
            vlanName[vlanId] = vlansTag["name"]

    trunk = j.get("trunk", [])

    for portTag in j["ports"]:
        port = portTag["num"]
        reason = valid(portTag)
        if reason!="":
            print("port %d incompatbles tags found: %s, skipping" % (port, reason))
        else:
            if port in ports:
                print("port %d already defined in ports, skipping" % (port) )
            else:
                # generation du modèle TP-Link
                ports.append(port)
                # vlan tagged
                # is trunk required
                vlanTagged = []
                useTrunk = portTag.get("trunk", False)
                if useTrunk==True:
                    vlanTagged = trunk
                else:
                    vlanTagged = portTag.get("tagged", [])

                # vlan untagged
                vlanUntagged = 0
                if isPresent(portTag, "untagged")==True:
                    vlanUntagged = portTag["untagged"]
                elif isPresent(portTag, "hybrid")==True:
                    vlanUntagged = portTag["hybrid"]
                    vlanTagged.remove(vlanUntagged)


                print("processing port %d" % (port) )

                # liste des ports pour le vlan untagged
                if (vlanUntagged > 0):
                    value = vlansPvid.get(vlanUntagged, [])
                    value.append(port)
                    vlansPvid[vlanUntagged] = value

                # liste des ports pour un vlan tagged
                updateList(port, vlansTaggedPorts, vlanTagged, vlanName)

                # liste des ports pour un vlan untagged
                temp = [vlanUntagged]
                updateList(port, vlansUntaggetPorts, temp, vlanName)


    

    global f
    f = open(fn, 'w')

    write(  '#######################################################################################')
    write(  '# configuration generated by ohmi')
    write(  '#     script:makeTpLinkVlan.py')
    write( ('#     Source: %s' % (descriptorFn) ) )
    write( ('#     on: %s' % (datetime.now().strftime("%Y/%m/%d %H:%M:%S") ) ) )
    write(  '#######################################################################################')
    write( "" )

    write(  '###############')
    write(  "# 802.1Q VLAN")
    write(  '###############')
    write( "" )
    for vlanId, name in vlanName.items():
        write("  vlan : %d name: %s" % (vlanId, name) )
        tmp=""
        for port in vlansTaggedPorts[vlanId]:
            tmp = tmp + ' ' + str(port) + ','
        write("    tagged : %s" % (tmp))
        tmp=""
        if (vlanId in vlansUntaggetPorts):
            for port in vlansUntaggetPorts[vlanId]:
                # tagged est prioritaire si présent dans les 2 listes
                tmp = tmp + ' ' + str(port) + ','
            if len(tmp) > 0:
                write("    untagged : %s" % (tmp))
        write( "" )
    
    write( "" )
    write(  '#######################')
    write(  "# 802.1Q PVID setting")
    write(  '#######################')
    write( "" )
    for vlanId, portList in vlansPvid.items():
        write("  pvid : %d" % (vlanId) )
        tmp=""
        for port in portList:
            tmp = tmp + ' ' + str(port) + ','
        write("    ports : %s" % (tmp))
        write( "" )

    f.close()


def write(s:str)->None:
    f.write('%s\n' % (s) )


def updateList(port, mainList, portList, validVlans):
    for tag in portList:
        if tag in validVlans:
            value = mainList.get(tag, [])
            value.append(port)
            mainList[tag] = value
        else:
            print("vlan %d not defined in vlans for port %d, skipping" % (tag, port) )


def valid(port)->str:
    isHybrid   = isPresent(port, "hybrid")
    isTrunk    = isPresent(port, "trunk")
    isTagged   = isPresent(port, "tagged")
    isUntagged = isPresent(port, "untagged")
    invalid=""
    if (isTrunk and isTagged):
        invalid="trunk/tagged"
    elif (isHybrid and isUntagged):
        invalid = "hybrid/untagged"
    return invalid

def isPresent(json, tag):
    rc = tag in json
    return rc

main()
